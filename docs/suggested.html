<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.4" />
<title>piktok.suggested API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>piktok.suggested</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from collections import deque
from random import sample
from typing import List
from tqdm import tqdm

import jmespath as jp
from aiohttp import ClientSession
from colored import stylize

from .base import Base, ERROR, s_print, INFO


class Suggested(Base):
    &#34;&#34;&#34;
    Class to get suggested users, musics, and challenges.
    &#34;&#34;&#34;

    _headers = {
        &#34;accept&#34;: &#34;application/json, text/plain, */*&#34;,
        &#34;user-agent&#34;: &#34;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36&#34;,
        &#34;accept-language&#34;: &#34;en-US,en;q=0.9&#34;,
        &#34;accept-encoding&#34;: &#34;gzip&#34;,
    }

    _params = {
        &#34;noUser&#34;: 0,
        &#34;userCount&#34;: 30,
        &#34;userId&#34;: &#34;&#34;,
    }

    _url = &#34;https://m.tiktok.com/node/share/discover&#34;

    def __init__(self, session: ClientSession, proxy: str):
        super().__init__(session, proxy)

    @staticmethod
    def __separate_results(results_list: list, no_user: bool) -&gt; dict:
        &#34;&#34;&#34;
        Transform the results of finding suggested users, musics, and challenges from list of lists to dict of lists

        Args:
            results_list (list): list of lists (each child list corresponds to either user, challege, and music
            no_user (bool): whether there is a list of users at the start of the list or not

        Returns:
            dict: converted dictionary

        &#34;&#34;&#34;
        if no_user:
            return {&#34;challenge&#34;: results_list[0], &#34;music&#34;: results_list[1]}
        return {
            &#34;user&#34;: results_list[0],
            &#34;challenge&#34;: results_list[1],
            &#34;music&#34;: results_list[2],
        }

    @classmethod
    def __merge_crawl_results(cls, results_list: List[dict]) -&gt; dict:
        &#34;&#34;&#34;
        Merge together the results of crawling from a list of many dicts sharing
        the same keys to one dict with those keys

        Args:
            results_list (list): list of dicts with &#39;users&#39;, &#39;challenges&#39;, and &#39;musics&#39; keys

        Returns:
            dict: dict merged from the lists
        &#34;&#34;&#34;
        users = challenges = musics = []
        for result_dict in results_list:
            users.extend(result_dict.get(&#34;user&#34;, []))
            challenges.extend(result_dict.get(&#34;challenge&#34;, []))
            musics.extend(result_dict.get(&#34;music&#34;, []))
        return cls.__separate_results([users, challenges, musics], False)

    async def fetch(
        self, user_id: str = None, user_count: int = 30, no_user: bool = False, **kwargs
    ) -&gt; dict:
        &#34;&#34;&#34;
        Fetch suggested users, musics, and challenges.

        Args:
            user_id (int): ID of the TikTok user for whom suggestions are made
            user_count (int): number of suggested users (only) to return from the call
            no_user (bool): whether or not to return suggested users
            **kwargs: any other path parameters

        Returns:
            dict: dict of the suggested elements
        &#34;&#34;&#34;
        if user_count &gt; 99:
            raise ValueError((&#34;user_count must be &lt; 100&#34;, &#34;red&#34;))

        url = self._url

        explicit_kwargs = {
            &#34;user_id&#34;: user_id,
            &#34;user_count&#34;: user_count,
            &#34;no_user&#34;: int(no_user),
        }

        response = await self._get_data(
            url, self._headers, explicit_kwargs, self._proxy, **kwargs
        )

        return self.__separate_results(
            jp.search(&#34;body[*].exploreList&#34;, response), no_user
        )

    async def crawl(
        self,
        depth: int = 1,
        choice_count: int = 1,
        user_id: str = None,
        user_count: int = 30,
        **kwargs
    ) -&gt; dict:
        &#34;&#34;&#34;
        Crawl many suggested elements by using a spider

        Args:
            depth (int): the depth of crawling (depth * choice_count = number of calls made)
            choice_count (int): how many user IDs to sample from each result set to crawl on next
            user_id (int): starting user ID
            user_count (int): how many suggested users to return from each call
            **kwargs: other path parameters

        Returns:
            dict: dict of crawled suggested elements
        &#34;&#34;&#34;
        if user_count &lt; choice_count or user_count &lt; 10:
            raise ValueError(
                stylize(&#34;user_count must be &gt;= choice_count and &gt;= 10&#34;, ERROR)
            )

        user_ids_queue = deque([user_id])
        limit = depth * choice_count
        level = 0
        results = []

        s_print(&#34;Starting crawler...&#34;, INFO)

        with tqdm(total=(choice_count ** 2) * depth + 1) as pbar:
            while len(user_ids_queue):
                next_user_id = user_ids_queue.popleft()

                items = await self.fetch(next_user_id, user_count, False, **kwargs)
                results.append(items)

                response_user_ids = [
                    item[&#34;cardItem&#34;][&#34;id&#34;] for item in items.get(&#34;user&#34;, [])
                ]

                pbar.update()
                if level &lt; limit:
                    user_ids_queue.extend(sample(response_user_ids, choice_count))
                    level += 1

        return self.__merge_crawl_results(results)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="piktok.suggested.Suggested"><code class="flex name class">
<span>class <span class="ident">Suggested</span></span>
<span>(</span><span>session: aiohttp.client.ClientSession, proxy: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Class to get suggested users, musics, and challenges.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Suggested(Base):
    &#34;&#34;&#34;
    Class to get suggested users, musics, and challenges.
    &#34;&#34;&#34;

    _headers = {
        &#34;accept&#34;: &#34;application/json, text/plain, */*&#34;,
        &#34;user-agent&#34;: &#34;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36&#34;,
        &#34;accept-language&#34;: &#34;en-US,en;q=0.9&#34;,
        &#34;accept-encoding&#34;: &#34;gzip&#34;,
    }

    _params = {
        &#34;noUser&#34;: 0,
        &#34;userCount&#34;: 30,
        &#34;userId&#34;: &#34;&#34;,
    }

    _url = &#34;https://m.tiktok.com/node/share/discover&#34;

    def __init__(self, session: ClientSession, proxy: str):
        super().__init__(session, proxy)

    @staticmethod
    def __separate_results(results_list: list, no_user: bool) -&gt; dict:
        &#34;&#34;&#34;
        Transform the results of finding suggested users, musics, and challenges from list of lists to dict of lists

        Args:
            results_list (list): list of lists (each child list corresponds to either user, challege, and music
            no_user (bool): whether there is a list of users at the start of the list or not

        Returns:
            dict: converted dictionary

        &#34;&#34;&#34;
        if no_user:
            return {&#34;challenge&#34;: results_list[0], &#34;music&#34;: results_list[1]}
        return {
            &#34;user&#34;: results_list[0],
            &#34;challenge&#34;: results_list[1],
            &#34;music&#34;: results_list[2],
        }

    @classmethod
    def __merge_crawl_results(cls, results_list: List[dict]) -&gt; dict:
        &#34;&#34;&#34;
        Merge together the results of crawling from a list of many dicts sharing
        the same keys to one dict with those keys

        Args:
            results_list (list): list of dicts with &#39;users&#39;, &#39;challenges&#39;, and &#39;musics&#39; keys

        Returns:
            dict: dict merged from the lists
        &#34;&#34;&#34;
        users = challenges = musics = []
        for result_dict in results_list:
            users.extend(result_dict.get(&#34;user&#34;, []))
            challenges.extend(result_dict.get(&#34;challenge&#34;, []))
            musics.extend(result_dict.get(&#34;music&#34;, []))
        return cls.__separate_results([users, challenges, musics], False)

    async def fetch(
        self, user_id: str = None, user_count: int = 30, no_user: bool = False, **kwargs
    ) -&gt; dict:
        &#34;&#34;&#34;
        Fetch suggested users, musics, and challenges.

        Args:
            user_id (int): ID of the TikTok user for whom suggestions are made
            user_count (int): number of suggested users (only) to return from the call
            no_user (bool): whether or not to return suggested users
            **kwargs: any other path parameters

        Returns:
            dict: dict of the suggested elements
        &#34;&#34;&#34;
        if user_count &gt; 99:
            raise ValueError((&#34;user_count must be &lt; 100&#34;, &#34;red&#34;))

        url = self._url

        explicit_kwargs = {
            &#34;user_id&#34;: user_id,
            &#34;user_count&#34;: user_count,
            &#34;no_user&#34;: int(no_user),
        }

        response = await self._get_data(
            url, self._headers, explicit_kwargs, self._proxy, **kwargs
        )

        return self.__separate_results(
            jp.search(&#34;body[*].exploreList&#34;, response), no_user
        )

    async def crawl(
        self,
        depth: int = 1,
        choice_count: int = 1,
        user_id: str = None,
        user_count: int = 30,
        **kwargs
    ) -&gt; dict:
        &#34;&#34;&#34;
        Crawl many suggested elements by using a spider

        Args:
            depth (int): the depth of crawling (depth * choice_count = number of calls made)
            choice_count (int): how many user IDs to sample from each result set to crawl on next
            user_id (int): starting user ID
            user_count (int): how many suggested users to return from each call
            **kwargs: other path parameters

        Returns:
            dict: dict of crawled suggested elements
        &#34;&#34;&#34;
        if user_count &lt; choice_count or user_count &lt; 10:
            raise ValueError(
                stylize(&#34;user_count must be &gt;= choice_count and &gt;= 10&#34;, ERROR)
            )

        user_ids_queue = deque([user_id])
        limit = depth * choice_count
        level = 0
        results = []

        s_print(&#34;Starting crawler...&#34;, INFO)

        with tqdm(total=(choice_count ** 2) * depth + 1) as pbar:
            while len(user_ids_queue):
                next_user_id = user_ids_queue.popleft()

                items = await self.fetch(next_user_id, user_count, False, **kwargs)
                results.append(items)

                response_user_ids = [
                    item[&#34;cardItem&#34;][&#34;id&#34;] for item in items.get(&#34;user&#34;, [])
                ]

                pbar.update()
                if level &lt; limit:
                    user_ids_queue.extend(sample(response_user_ids, choice_count))
                    level += 1

        return self.__merge_crawl_results(results)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="piktok.base.Base" href="base.html#piktok.base.Base">Base</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="piktok.suggested.Suggested.crawl"><code class="name flex">
<span>async def <span class="ident">crawl</span></span>(<span>self, depth: int = 1, choice_count: int = 1, user_id: str = None, user_count: int = 30, **kwargs) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Crawl many suggested elements by using a spider</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>depth</code></strong> :&ensp;<code>int</code></dt>
<dd>the depth of crawling (depth * choice_count = number of calls made)</dd>
<dt><strong><code>choice_count</code></strong> :&ensp;<code>int</code></dt>
<dd>how many user IDs to sample from each result set to crawl on next</dd>
<dt><strong><code>user_id</code></strong> :&ensp;<code>int</code></dt>
<dd>starting user ID</dd>
<dt><strong><code>user_count</code></strong> :&ensp;<code>int</code></dt>
<dd>how many suggested users to return from each call</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>other path parameters</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>dict of crawled suggested elements</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def crawl(
    self,
    depth: int = 1,
    choice_count: int = 1,
    user_id: str = None,
    user_count: int = 30,
    **kwargs
) -&gt; dict:
    &#34;&#34;&#34;
    Crawl many suggested elements by using a spider

    Args:
        depth (int): the depth of crawling (depth * choice_count = number of calls made)
        choice_count (int): how many user IDs to sample from each result set to crawl on next
        user_id (int): starting user ID
        user_count (int): how many suggested users to return from each call
        **kwargs: other path parameters

    Returns:
        dict: dict of crawled suggested elements
    &#34;&#34;&#34;
    if user_count &lt; choice_count or user_count &lt; 10:
        raise ValueError(
            stylize(&#34;user_count must be &gt;= choice_count and &gt;= 10&#34;, ERROR)
        )

    user_ids_queue = deque([user_id])
    limit = depth * choice_count
    level = 0
    results = []

    s_print(&#34;Starting crawler...&#34;, INFO)

    with tqdm(total=(choice_count ** 2) * depth + 1) as pbar:
        while len(user_ids_queue):
            next_user_id = user_ids_queue.popleft()

            items = await self.fetch(next_user_id, user_count, False, **kwargs)
            results.append(items)

            response_user_ids = [
                item[&#34;cardItem&#34;][&#34;id&#34;] for item in items.get(&#34;user&#34;, [])
            ]

            pbar.update()
            if level &lt; limit:
                user_ids_queue.extend(sample(response_user_ids, choice_count))
                level += 1

    return self.__merge_crawl_results(results)</code></pre>
</details>
</dd>
<dt id="piktok.suggested.Suggested.fetch"><code class="name flex">
<span>async def <span class="ident">fetch</span></span>(<span>self, user_id: str = None, user_count: int = 30, no_user: bool = False, **kwargs) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch suggested users, musics, and challenges.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>user_id</code></strong> :&ensp;<code>int</code></dt>
<dd>ID of the TikTok user for whom suggestions are made</dd>
<dt><strong><code>user_count</code></strong> :&ensp;<code>int</code></dt>
<dd>number of suggested users (only) to return from the call</dd>
<dt><strong><code>no_user</code></strong> :&ensp;<code>bool</code></dt>
<dd>whether or not to return suggested users</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>any other path parameters</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>dict of the suggested elements</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def fetch(
    self, user_id: str = None, user_count: int = 30, no_user: bool = False, **kwargs
) -&gt; dict:
    &#34;&#34;&#34;
    Fetch suggested users, musics, and challenges.

    Args:
        user_id (int): ID of the TikTok user for whom suggestions are made
        user_count (int): number of suggested users (only) to return from the call
        no_user (bool): whether or not to return suggested users
        **kwargs: any other path parameters

    Returns:
        dict: dict of the suggested elements
    &#34;&#34;&#34;
    if user_count &gt; 99:
        raise ValueError((&#34;user_count must be &lt; 100&#34;, &#34;red&#34;))

    url = self._url

    explicit_kwargs = {
        &#34;user_id&#34;: user_id,
        &#34;user_count&#34;: user_count,
        &#34;no_user&#34;: int(no_user),
    }

    response = await self._get_data(
        url, self._headers, explicit_kwargs, self._proxy, **kwargs
    )

    return self.__separate_results(
        jp.search(&#34;body[*].exploreList&#34;, response), no_user
    )</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="piktok.base.Base" href="base.html#piktok.base.Base">Base</a></b></code>:
<ul class="hlist">
<li><code><a title="piktok.base.Base.get_default_params" href="base.html#piktok.base.Base.get_default_params">get_default_params</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="piktok" href="index.html">piktok</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="piktok.suggested.Suggested" href="#piktok.suggested.Suggested">Suggested</a></code></h4>
<ul class="">
<li><code><a title="piktok.suggested.Suggested.crawl" href="#piktok.suggested.Suggested.crawl">crawl</a></code></li>
<li><code><a title="piktok.suggested.Suggested.fetch" href="#piktok.suggested.Suggested.fetch">fetch</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.4</a>.</p>
</footer>
</body>
</html>